*** My Emacs Configuration
A fast and sane emacs configuration with the stuff that i use configured, these stuff are:
- Gnus for newsreading
 - Ivy for minibuffer completion because i cant with helm(no swiper because i also hate that)
- A funny dashboard
- Org roam for storing knowledge
- LSP stuff
** Screenshots and Stuff i Guess
#+CAPTION: Editing the init file and gnus
[[../img/a.png]] [[../img/b.png]]
* Garbage collection and performance tweaks
Here we use gcmh for better garbage collection, make the initial-major-mode fundemental mode
and do more performance tweaks.
#+BEGIN_SRC emacs-lisp



      #+END_SRC
* Startup hook
This turns on gcmh, tells us our startup time and turns on ivy - moved to early-init
#+BEGIN_SRC emacs-lisp

#+END_SRC
* Small configurations to make emacs bearable
#+BEGIN_SRC emacs-lisp
      (defun efs/display-startup-time ()
        (message "Emacs loaded in %s with %d garbage collections."
    	       (format "%.2f seconds"
    		       (float-time
    		       (time-subtract after-init-time before-init-time)))
    	       gcs-done))
  (defun gc-restore ()
    (setq gc-cons-threshold 1200000))
       (add-hook 'emacs-startup-hook #'gc-restore)
      (add-hook 'emacs-startup-hook #'efs/display-startup-time)
      (straight-use-package 'use-package)
        (setq inhibit-startup-message t)
    (use-package straight
      :custom
      
  (setq straight-check-for-modifications 'live-with-find)
      (setq display-line-numbers-type 'relative)
      (straight-use-package-by-default t))
        (add-hook 'prog-mode-hook 'display-line-numbers-mode)
        (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+END_SRC

  This is for my shell config so it doesnt open GNU screen when im in emacs terminal.
  #+BEGIN_SRC emacs-lisp
  (setenv "IN_EMACS" "1")
#+END_SRC

*** Packages
* Some notes
Most of these are deffered to optimize startup time.
* The actual stuff

Keycast(the funny keylogger that shows at the top) - Make the keycast thing show at the top
Unnessecary now, i know what im doing
#+BEGIN_SRC emacs-lisp
  ;; (use-package keycast
  ;;   :config
  ;;   (keycast-tab-bar-mode))
  #+END_SRC
  
  Treemacs - File Tree i dont use that much, has some git stuff here.
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :after (dashboard ivy)
   :commands (treemacs)
   :config
   (progn
      (add-hook 'treemacs-mode-hook (lambda() (display-line-numbers-mode -1)))
      (treemacs-fringe-indicator-mode 'always)
      (when treemacs-python-executable
        (treemacs-git-commit-diff-mode t))
      (pcase (cons (not (null (executable-find "git")))
                   (not (null treemacs-python-executable)))
        (`(t . t)
         (treemacs-git-mode 'deferred))
        (`(t . _)
         (treemacs-git-mode 'simple)))
      (treemacs-hide-gitignored-files-mode nil))
   :bind
   (("M-0" . treemacs)))

#+END_SRC
Some eww stuff(very gross)

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'eww-browse-url
      shr-use-colors nil
      shr-bullet "• "
      shr-folding-mode t
      eww-search-prefix "https://html.duckduckgo.com/html?q="
      url-privacy-level '(email agent cookies lastloc)
      browse-url-secondary-browser-function 'browse-url-firefox)
(setq browse-url-browser-function 'eww-browse-url)
#+END_SRC

Dashboard - Custom logo for it, use nerd icons
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :defer nil
  :config
     (dashboard-setup-startup-hook)
     ;; Set the title
     (setq dashboard-banner-logo-title "Oblivikun Emacs")
     ;; Set the banner
     (setq dashboard-startup-banner (expand-file-name "branding/logo.png" user-emacs-directory))

     (setq dashboard-center-content t)
    (setq dashboard-display-icons-p t)     ; display icons on both GUI and terminal
    (setq dashboard-icon-type 'nerd-icons) ; use `nerd-icons' package
     ;; vertically center content
     ; use `nerd-icons' package
    (setq dashboard-filter-agenda-entry 'dashboard-no-filter-agenda)
#+END_SRC
Make the dashboard load when i start the daemon
#+BEGIN_SRC emacs-lisp
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
   (setq dashboard-vertically-center-content t))
#+END_SRC
Hydra So i can remember my keybinds
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :after (ivy dashboard)
    :defer t
    )
 #+END_SRC
doom (I reallly like the bar in doom and the normal bar looks weird)
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :hook (after-init . doom-modeline-mode))
#+END_SRC
Company for auto completions. I really like this package :)
#+BEGIN_SRC emacs-lisp
(use-package company
 :defer t
 :hook (prog-mode . company-mode)
 :config
 (setq-default
    company-idle-delay 0
    company-require-match nil
    ;; also get a drop down
    company-frontends '(company-pseudo-tooltip-frontend company-preview-frontend)))

#+END_SRC
Slime - Very nice when i do stuff with common lisp
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :after (lsp-mode ivy counsel)
   :defer t
   :hook (lisp-mode . slime-mode))

  #+END_SRC

*  Nyxt browser configurations for slime
Use sly to evaluate common lisp because it has better integration with nyxt.
#+BEGIN_SRC emacs-lisp
  (defcustom cl-ide 'slime
      "What IDE to use to evaluate Common Lisp.
Defaults to Sly because it has better integration with Nyxt."
   :options (list 'sly 'slime))
  #+END_SRC
Delay to wait for 'cl-ide' commands to reach nyxt
#+BEGIN_SRC emacs-lisp
(defvar emacs-with-nyxt-delay
  0.1)

(setq slime-protocol-version 'ignore)
#+END_SRC
Check if emacs is connected to nyxt.
#+BEGIN_SRC emacs-lisp
(defun emacs-with-nyxt-connected-p ()
  "Is `cl-ide' connected to nyxt."
  (cond
   ((eq cl-ide 'slime) (slime-connected-p))
   ((eq cl-ide 'sly) (sly-connected-p))))
   #+END_SRC
   Connect to cl-ide to HOST and PORT.
   #+BEGIN_SRC emacs-lisp
      (defun emacs-with-nyxt--connect (host port)
	  "Connect `cl-ide' to HOST and PORT."
     (cond
      ((eq cl-ide 'slime) (slime-connect host port))
      ((eq cl-ide 'sly) (sly-connect host port))))
   #+END_SRC
   Do the same thing ignoring version mismatches.
   #+BEGIN_SRC emacs-lisp
      (defun emacs-with-nyxt-connect (host port)
	  "Connect `cl-ide' to HOST and PORT."
     (emacs-with-nyxt--connect host port)
     (while (not (emacs-with-nyxt-connected-p))
       (message "Starting %s connection..." cl-ide)
       (sleep-for emacs-with-nyxt-delay)))
  #+END_SRC
  Send STRING to cl-ide.
  #+BEGIN_SRC emacs-lisp
    (defun emacs-with-nyxt-eval (string)
        "Send STRING to `cl-ide'."
    (cond
     ((eq cl-ide 'slime) (slime-repl-eval-string string))
     ((eq cl-ide 'sly) (sly-eval `(slynk:interactive-eval-region ,string)))))
   #+END_SRC
Evaluate S-EXPS with nyxt 'cl-ide' session
#+BEGIN_SRC emacs-lisp
  (defun emacs-with-nyxt-send-sexps (&rest s-exps)
    "Evaluate S-EXPS with Nyxt `cl-ide' session."
    (let ((s-exps-string (s-join "" (--map (prin1-to-string it) s-exps))))
      (defun true (&rest args) 't)
      (if (emacs-with-nyxt-connected-p)
	  (emacs-with-nyxt-eval s-exps-string)
	(error (format "%s is not connected to Nyxt. Run `emacs-with-nyxt-start-and-connect-to-nyxt' first" cl-ide)))))
      #+END_SRC
Return current package set for 'cl-ide'
#+BEGIN_SRC emacs-lisp

  (defun emacs-with-nyxt-current-package ()
    "Return current package set for `cl-ide'."
    (cond
     ((eq cl-ide 'slime) (slime-current-package))
     ((eq cl-ide 'sly) (with-current-buffer (sly-mrepl--find-buffer) (sly-current-package)))))
   #+END_SRC
   Start nyxt with swank and connect to nyxt
   #+BEGIN_SRC emacs-lisp
   (defun emacs-with-nyxt-start-and-connect-to-nyxt (&optional no-maximize)
  "Start Nyxt with swank capabilities. Optionally skip window maximization with NO-MAXIMIZE."
  (interactive)
  (async-shell-command (format "nyxt" ;; "nyxt -e \"(nyxt-user::start-swank)\""
                               ))
  (while (not (emacs-with-nyxt-connected-p))
    (message (format "Starting %s connection..." cl-ide))
    (ignore-errors (emacs-with-nyxt-connect "localhost" "4006"))
    (sleep-for emacs-with-nyxt-delay))
  (while (not (ignore-errors (string= "NYXT-USER" (upcase (emacs-with-nyxt-current-package)))))
    (progn (message "Setting %s package to NYXT-USER..." cl-ide)
           (sleep-for emacs-with-nyxt-delay)))
  (emacs-with-nyxt-send-sexps
   `(load "~/quicklisp/setup.lisp")
   `(defun replace-all (string part replacement &key (test #'char=))
      (with-output-to-string (out)
                             (loop with part-length = (length part)
                                   for old-pos = 0 then (+ pos part-length)
                                   for pos = (search part string
                                                     :start2 old-pos
                                                     :test test)
                                   do (write-string string out
                                                    :start old-pos
                                                    :end (or pos (length string)))
                                   when pos do (write-string replacement out)
                                   while pos)))
#+END_SRC
Evaluate S-EXPS with emacs
#+BEGIN_SRC emacs-lisp
   `(defun eval-in-emacs (&rest s-exps)
      "Evaluate S-EXPS with emacsclient."
      (let ((s-exps-string (replace-all
                            (write-to-string
                             `(progn ,@s-exps) :case :downcase)
                            ;; Discard the package prefix.
                            "nyxt::" "")))
        (format *error-output* "Sending to Emacs:~%~a~%" s-exps-string)
        (uiop:run-program
         (list "emacsclient" "--eval" s-exps-string))))e
#+END_SRC
QR code stuff 
#+BEGIN_SRC emacs-lisp
  `(ql:quickload "cl-qrencode")
  `(define-command-global my/make-current-url-qr-code () ; this is going to be redundant: https://nyxt.atlas.engineer/article/qr-url.org
			        "Something else."
     (when (find-mode (current-buffer) 'web-mode)
       (cl-qrencode:encode-png (quri:render-uri (url (current-buffer))) :fpath "/tmp/qrcode.png")
       (uiop:run-program (list "nyxt" "/tmp/qrcode.png"))))
#+END_SRC
Open buffer html in emacs
#+BEGIN_SRC emacs-lisp
  '(define-command-global my/open-html-in-emacs ()
			        "Open buffer html in Emacs."
     (when (find-mode (current-buffer) 'web-mode)
       (with-open-file
	(file "/tmp/temp-nyxt.html" :direction :output
	      :if-exists :supersede
	      :if-does-not-exist :create)
	(write-string (ffi-buffer-get-document (current-buffer)) file)))
     (eval-in-emacs
      `(progn (switch-to-buffer
	       (get-buffer-create ,(render-url (url (current-buffer)))))
	      (erase-buffer)
	      (insert-file-contents-literally "/tmp/temp-nyxt.html")
	      (html-mode)
	      (indent-region (point-min) (point-max))))
     (delete-file "/tmp/temp-nyxt.html"))
      #+END_SRC
  From @aartaka https://www.reddit.com/r/Nyxt/comments/ock3tu/is_there_something_like_mx_or_esc_in_nyxt/h3wkipl?utm_source=share&utm_medium=web2x&context=3
  Prompt for the expression and evaluate it, echoing result to the 'message-area'.
Reads an arbritrary expression with no error checking and messages it to the message area
  #+BEGIN_SRC emacs-lisp
     `(define-command-global eval-expression ()
      "Prompt for the expression and evaluate it, echoing result to the `message-area'."
      (let ((expression-string
             (first (prompt :prompt "Expression to evaluate"
                            :sources (list (make-instance 'prompter:raw-source))))))
        (echo "~S" (eval (read-from-string expression-string)))))
#+END_SRC
Bind eval-expression to M-:, but only in emacs-mode.
  #+BEGIN_SRC emacs-lisp
   `(define-configuration nyxt/web-mode:web-mode
      ((keymap-scheme (let ((scheme %slot-default%))
                        (keymap:define-key (gethash scheme:emacs scheme)
                                           "M-:" 'eval-expression)
                        scheme))))
#+END_SRC
Capture link
#+BEGIN_SRC emacs-lisp
  `(defun emacs-with-nyxt-capture-link ()
	(let ((url (quri:render-uri (url (current-buffer)))))
	  (if (str:containsp "youtu" url)
	      (str:concat
	       url
	       "&t="
	       (write-to-string
		(floor
		 (ffi-buffer-evaluate-javascript (current-buffer)
						 (ps:ps
						  (ps:chain document
							    (get-element-by-id "movie_player")
							    (get-current-time))))))
	       "s")
	    url)))
#+END_SRC
Org-capture current page
#+BEGIN_SRC emacs-lisp
  `(define-command-global org-capture ()
	(eval-in-emacs
	 `(let ((org-link-parameters
		 (list (list "nyxt"
			     :store
			     (lambda ()
			       (org-store-link-props
				:type "nyxt"
				:link ,(emacs-with-nyxt-capture-link)
				:description ,(title (current-buffer))))))))
	    (org-capture nil "wN"))
	 (echo "Note stored!")))
#+END_SRC
org-roam capture
#+BEGIN_SRC emacs-lisp
  `(define-command-global org-roam-capture ()
	(let ((quote (%copy))
	      (link (emacs-with-nyxt-capture-link))
	      (title (prompt
		      :input (title (current-buffer))
		      :prompt "Title of note:"
		      :sources (list (make-instance 'prompter:raw-source))))
	      (text (prompt
		     :input ""
		     :prompt "Note to take:"
		     :sources (list (make-instance 'prompter:raw-source)))))
	  (eval-in-emacs
	   `(let ((_ (require 'org-roam))
		  (file (on/make-filepath ,(car title) (current-time))))
	      (on/insert-org-roam-file
	       file
	       ,(car title)
	       nil
	       (list ,link)
	       ,(car text)
	       ,quote)
	      (find-file file)
	      (org-id-get-create)))
	  (echo "Org Roam Note stored!")))
     `(define-configuration nyxt/web-mode:web-mode
	((keymap-scheme (let ((scheme %slot-default%))
			  (keymap:define-key (gethash scheme:emacs scheme)
					     "C-c o c" 'org-capture)
			  scheme))))
     `(define-configuration nyxt/web-mode:web-mode
	((keymap-scheme (let ((scheme %slot-default%))
			  (keymap:define-key (gethash scheme:emacs scheme)
					     "C-c n f" 'org-roam-capture)
			  scheme))))
     )
    (unless no-maximize
      (emacs-with-nyxt-send-sexps
       '(toggle-fullscreen))))
  #+END_SRC
Open URL with nyxt and optionally define BUFFER-TITLE
#+BEGIN_SRC emacs-lisp
(defun emacs-with-nyxt-browse-url-nyxt (url &optional buffer-title)
  (interactive "sURL: ")
  (emacs-with-nyxt-send-sexps
   (append
    (list
     'buffer-load
     url)
    (if buffer-title
        `(:buffer (make-buffer :title ,buffer-title))
      nil))))
#+END_SRC
Close connection
#+BEGIN_SRC emacs-lisp
(defun emacs-with-nyxt-close-nyxt-connection ()
  (interactive)
  (emacs-with-nyxt-send-sexps '(quit)))
  #+END_SRC
 Browse URL with Nyxt. NEW-WINDOW is ignored.
#+BEGIN_SRC emacs-lisp
(defun browse-url-nyxt (url &optional new-window)
  (interactive "sURL: ")
  (unless (emacs-with-nyxt-connected-p) (emacs-with-nyxt-start-and-connect-to-nyxt))
  (emacs-with-nyxt-browse-url-nyxt url url))
  #+END_SRC
  Search current nyxt buffer for STRING
  #+BEGIN_SRC emacs-lisp
  (defun emacs-with-nyxt-search-first-in-nyxt-current-buffer (string)
  (interactive "sString to search: ")
  (unless (emacs-with-nyxt-connected-p) (emacs-with-nyxt-start-and-connect-to-nyxt))
  (emacs-with-nyxt-send-sexps
   `(nyxt/web-mode::highlight-selected-hint
     :link-hint
     (car (nyxt/web-mode::matches-from-json
           (nyxt/web-mode::query-buffer :query ,string)))
     :scroll 't)))
     #+END_SRC
     Make qr code of current url
     #+BEGIN_SRC emacs-lisp
     (defun emacs-with-nyxt-make-qr-code-of-current-url ()
  (interactive)
  (if (file-exists-p "~/quicklisp/setup.lisp")
      (progn
        (unless (emacs-with-nyxt-connected-p) (emacs-with-nyxt-start-and-connect-to-nyxt))
        (emacs-with-nyxt-send-sexps
         '(ql:quickload "cl-qrencode")
         '(cl-qrencode:encode-png (quri:render-uri (url (current-buffer))) :fpath "/tmp/qrcode.png"))
        (find-file "/tmp/qrcode.png")
        (auto-revert-mode))
    (error "You cannot use this until you have Quicklisp installed! Check how to do that at: https://www.quicklisp.org/beta/#installation")))
    #+END_SRC
    Return nyxt buffers
    #+BEGIN_SRC emacs-lisp
    (defun emacs-with-nyxt-get-nyxt-buffers ()
  (when (emacs-with-nyxt-connected-p)
    (read
     (emacs-with-nyxt-send-sexps
      '(map 'list (lambda (el) (slot-value el 'title)) (buffer-list))))))
#+END_SRC
Interactively switch nyxt buffers.  If argument is provided switch to buffer with TITLE.
#+BEGIN_SRC emacs-lisp
(defun emacs-with-nyxt-nyxt-switch-buffer (&optional title)
  (interactive)
  (if (emacs-with-nyxt-connected-p)
      (let ((title (or title (completing-read "Title: " (emacs-with-nyxt-get-nyxt-buffers)))))
        (emacs-with-nyxt-send-sexps
         `(switch-buffer :id (slot-value (find-if #'(lambda (el) (equal (slot-value el 'title) ,title)) (buffer-list)) 'id))))
    (error (format "%s is not connected to Nyxt. Run `emacs-with-nyxt-start-and-connect-to-nyxt' first" cl-ide))))
#+END_SRC
Get nyxt commands.
#+BEGIN_SRC emacs-lisp
      (defun emacs-with-nyxt-get-nyxt-commands ()
	(when (emacs-with-nyxt-connected-p)
	  (read
	   (emacs-with-nyxt-send-sexps
	    `(let ((commands (make-instance 'command-source)))

	       (map 'list (lambda (el) (slot-value el 'name)) (funcall (slot-value commands 'prompter:CONSTRUCTOR) commands)))))))
#+END_SRC
Run nyxt commands
#+BEGIN_SRC emacs-lisp
(defun emacs-with-nyxt-nyxt-run-command (&optional command)
  (interactive)
  (if (emacs-with-nyxt-connected-p)
      (let ((command (or command (completing-read "Execute command: " (emacs-with-nyxt-get-nyxt-commands)))))
        (emacs-with-nyxt-send-sexps `(nyxt::run-async ',(read command))))
    (error (format "%s is not connected to Nyxt. Run `emacs-with-nyxt-start-and-connect-to-nyxt' first" cl-ide))))
#+END_SRC
Take over the nyxt prompt and let Emacs handle completions.
#+BEGIN_SRC emacs-lisp
(defun emacs-with-nyxt-nyxt-take-over-prompt ()
  (interactive)
  (emacs-with-nyxt-send-sexps
   `(progn
      (defun flatten (structure)
        (cond ((null structure) nil)
              ((atom structure) (list structure))
              (t (mapcan #'flatten structure))))
      
      (defun prompt (&REST args)
        (flet ((ensure-sources (specifiers)
                               (mapcar (lambda (source-specifier)
                                         (cond
                                          ((and (symbolp source-specifier)
                                                (c2cl:subclassp source-specifier 'source))
                                           (make-instance source-specifier))
                                          (t source-specifier)))
                                       (uiop:ensure-list specifiers))))
              (sleep 0.1)
              (let* ((promptstring (list (getf args :prompt)))
                     (sources (ensure-sources (getf args :sources)))
                     (names (mapcar (lambda (ol) (slot-value ol 'prompter:attributes)) (flatten (mapcar (lambda (el) (slot-value el 'PROMPTER::INITIAL-SUGGESTIONS)) sources))))
                     (testing (progn
                                (setq my-names names)
                                (setq my-prompt promptstring)))
                     (completed (read-from-string (eval-in-emacs `(emacs-with-nyxt-nyxt-complete ',promptstring ',names))))
                     (suggestion
                      (find-if (lambda (el) (equal completed (slot-value el 'PROMPTER::ATTRIBUTES))) (flatten (mapcar (lambda (el) (slot-value el 'PROMPTER::INITIAL-SUGGESTIONS)) sources))))
                     (selected-class (find-if (lambda (el) (find suggestion (slot-value el 'PROMPTER::INITIAL-SUGGESTIONS))) sources)))
                (if selected-class
                    (funcall (car (slot-value selected-class 'PROMPTER::ACTIONS)) (list (slot-value suggestion 'PROMPTER:VALUE)))
                  (funcall (car (slot-value (car sources) 'PROMPTER::ACTIONS)) (list completed)))))))))
#+END_SRC
Completion function for nyxt completion
#+BEGIN_SRC emacs-lisp
(defun emacs-with-nyxt-nyxt-complete (prompt names)
  (let* ((completions (--map (s-join "\t" (--map (s-join ": " it) it)) names))
         (completed-string (completing-read (s-append ": " (car prompt)) completions))
         (completed-index (-elem-index  completed-string completions)))
    (if (numberp completed-index)
        (nth completed-index names)
      completed-string)))
      #+END_SRC
Decode an ENCODED link containing some elisp. This is for the '.ag91' links
#+BEGIN_SRC emacs-lisp
(defun emacs-with-nyxt-decode-command (encoded)
  (--> encoded
       (s-split "/" it t)
       reverse
       car
       (s-split "\\." it t)
       car
       base64-decode-string
       read
       eval))
#+END_SRC
* End of the nyxt stuff
#+BEGIN_SRC emacs-lisp
(provide 'emacs-with-nyxt)
#+END_SRC
* LSP stuff - turn off some things that make performance worse and some stuff i just like
#+BEGIN_SRC emacs-lisp

  (use-package lsp-mode
    :after (ivy counsel)
    :defer t
    :init
    (setq lsp-keymap-prefix "C-c l")
    :hook (
           (python-mode . lsp)
  	 (haskell-mode . lsp)
  	 (c-or-c++-mode . lsp)
  	 (go-mode . lsp)
           (lsp-mode . lsp-enable-which-key-integration))
    :config
     (setq lsp-enable-symbol-highlighting nil)
    (setq lsp-enable-on-type-formatting nil)
    (setq lsp-signature-auto-activate nil)
    (setq lsp-signature-render-documentation nil)
    (setq lsp-eldoc-hook nil)
    (setq lsp-modeline-code-actions-enable nil)
    (setq lsp-modeline-diagnostics-enable nil)
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq lsp-semantic-tokens-enable nil)
    (setq lsp-enable-folding nil)
    (setq lsp-enable-imenu nil)
    (setq lsp-enable-snippet nil)
    :commands lsp)
  #+END_SRC
  LSP-ui because i need that(so helpfull) and ivy stuff.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :after (lsp-mode)
   :defer t
   :hook (lsp-mode . lsp-ui-mode))

  ;; if you are ivy user
  (use-package lsp-ivy
    :after (lsp-mode)
    :defer t
    :commands lsp-ivy-workspace-symbol)
  #+END_SRC
  Optionally use eglot
  #+BEGIN_SRC emacs-lisp
  ;; (add-hook 'prog-mode-hook #'eglot-ensure)
;; (with-eval-after-load 'eglot
;;  (add-to-list 'eglot-server-programs
;;                '(emacs-lisp-mode . ("emacs-lsp" "--stdio"))))
#+END_SRC
* My custom keybinds for terminal stuff because i like a terminal at the bottom
Split the window and open a terminal in the new window, taking only a quarter of the screen.
Height of top window is 1/4 of the frame height.
#+BEGIN_SRC emacs-lisp
    (defun open-terminal-at-bottom ()
   (interactive)
   (let ((height (window-body-height)))
     (split-window-below (- height (/ height 4)))) 
   (other-window 1)
   (term "ksh"))
#+END_SRC
Close the terminal window at the bottom or the current window if its a terminal
#+BEGIN_SRC emacs-lisp
  (defun close-terminal-at-bottom ()
   (interactive)
   (let ((current-window (selected-window)))
      (if (eq 'term-mode (buffer-local-value 'major-mode (window-buffer current-window)))
	  #+END_SRC
	  If the current window window is a terminal, close it.
	  #+BEGIN_SRC emacs-lisp
		    (delete-window current-window)
        #+END_SRC
	    If the current window is not a terminal, check if there is a terminal below.
	    #+BEGIN_SRC emacs-lisp
	    (when (and (window-live-p (next-window))
			     (eq 'term-mode (buffer-local-value 'major-mode (window-buffer (next-window)))))
		    (delete-window (next-window))))))
#+END_SRC
Split the window and open a Python shell in the new window, taking only a quarter of the screen.
#+BEGIN_SRC emacs-lisp
	    (defun open-python-shell-at-bottom ()
	     (interactive)
	     (let ((height (window-body-height)))
		(split-window-below (- height (/ height 4)))) 
	     (other-window 1)
	     (term "python3"))
#+END_SRC
Make the hydra
#+BEGIN_SRC emacs-lisp
	    (defhydra hydra-terminal-python-manager (:color blue)
	     "Terminal/Python"
	     ("t" open-terminal-at-bottom "Open Terminal")
	     ("q" close-terminal-at-bottom "Close Terminal")
	     ("p" open-python-shell-at-bottom "Open Python Shell"))

	    (global-set-key (kbd "C-c t") 'hydra-terminal-python-manager/body)
#+END_SRC
* Org Mode Configs
Make org mode default for .org files
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
#+END_SRC
Org - Roam
MAKE SURE TO MAKE THE DIRECTORY ~/roam
#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :defer 10
   :after (org)
   :init
   (setq org-roam-directory (file-truename "~/roam/"))
   :custom
   (org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
   :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n g" . org-roam-graph)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n c" . org-roam-capture)
           ;; Dailies
           ("C-c n j" . org-roam-dailies-capture-today))
   :config
   (org-roam-db-autosync-mode)
   ;; Additional configuration and custom functions can be added here
   )

  #+END_SRC
Make Org more beautifull
#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
    (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    (use-package org-bullets
      :defer nil
      :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
    (add-hook 'org-mode-hook 'visual-line-mode)
#+END_SRC
  Org Keybindings
    #+BEGIN_SRC emacs-lisp
      (defun my-org-todo-toggle ()
    (interactive)
    (let ((state (org-get-todo-state)))
      (if (string= state "TODO")
          (org-todo "DONE")
        (org-todo "TODO")))
    (org-flag-subtree t))
  (define-key org-mode-map (kbd "C-c C-d") 'my-org-todo-toggle)
  (defun my-org-insert-todo ()
    (interactive)
    (org-insert-todo-heading nil))
  (define-key org-mode-map (kbd "C-c C-t") 'my-org-insert-todo)
  (defun org-deadline-in-one-week ()
    (interactive)
    (org-deadline nil "+1w"))
  (global-set-key (kbd "C-c d") 'org-deadline-in-one-week)
    #+END_SRC
    Org agenda configuration
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-files '("~/agenda.org"))
(setq org-todo-keywords
      '((sequence "TODO" "IN-PROGRESS" "WAITING" "DONE")))
(setq org-agenda-todo-ignore-scheduled t)
(setq org-agenda-todo-ignore-deadlines t)
(defun my-split-and-open-todo-list ()
  "Split the window to the side and open the Org agenda."
  (interactive)
  (split-window-right)
  (other-window 1)
  (org-agenda nil "t"))
(global-set-key (kbd "C-c a") 'my-split-and-open-todo-list)
      #+END_SRC
      Export hydra thing for org because i hate the default dispatcher
      #+BEGIN_SRC emacs-lisp
(defhydra hydra-org-export-and-view ()
 "Export and view"
 ("h" (org-html-export-to-html) "Export to HTML")
 ("o" (org-export-to-html-and-open-in-nyxt) "Open in Nyxt")
 ("l" (org-latex-export-to-latex) "Export to LaTeX")
 ("b" (org-beamer-export-to-latex) "Export to Beamer")
 ("d" (org-export-to-docx-and-open) "Export to DOCX")
 ("q" nil "quit"))
(define-key org-mode-map (kbd "C-c C-e") 'hydra-org-export-and-view/body)
#+END_SRC
Pandoc stuff for org
#+BEGIN_SRC emacs-lisp
(defun org-export-to-docx-and-open ()
 (interactive)
 (let ((docx-file (concat (file-name-base (buffer-file-name)) ".docx")))
    (shell-command (format "pandoc %s -o %s" (buffer-file-name) docx-file))
    (find-file docx-file)))
#+END_SRC
Export to html and open in nyxt
#+BEGIN_SRC emacs-lisp
(defun org-export-to-html-and-open-in-nyxt ()
 "Export the current Org file to HTML and open it in Nyxt."
 (interactive)
 (let ((html-file (org-html-export-to-html)))
    (start-process "Nyxt" nil "nyxt" html-file)
    (add-hook 'kill-emacs-hook
              (lambda ()
                (when (get-process "Nyxt")
                  (delete-process (get-process "Nyxt")))))))
#+END_SRC
Export to markdown and open in nyxt
#+BEGIN_SRC emacs-lisp
(defun markdown-export-to-html-and-open-in-nyxt ()
 "Export the current Markdown file to HTML and open it in Nyxt."
 (interactive)
 (let ((html-file (markdown-export)))
    (start-process "Nyxt" nil "nyxt" html-file)
    (add-hook 'kill-emacs-hook
              (lambda ()
                (when (get-process "Nyxt")
                 (delete-process (get-process "Nyxt")))))))
#+END_SRC
Keymap for org-export-to-html-and-open-in-nyxt
#+BEGIN_SRC emacs-lisp

(defvar org-export-to-html-and-open-in-nyxt-map (make-sparse-keymap)
 "Keymap for `org-export-to-html-and-open-in-nyxt'.")

(define-key org-export-to-html-and-open-in-nyxt-map (kbd "h o") 'org-export-to-html-and-open-in-nyxt)
(add-hook 'markdown-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c C-o") 'markdown-export-to-html-and-open-in-nyxt)))
#+END_SRC
	Some stuff for dumping emacs
       Generate the lines to include in the lisp/loadup.el file
      to place all of the libraries that are loaded by your InitFile
      into the main dumped emacs.
#+BEGIN_SRC emacs-lisp
	(defun loadup-gen ()
       (interactive)
       (defun get-loads-from-*Messages* ()
	  (save-excursion
	    (let ((retval ()))
	      (set-buffer "*Messages*")
	      (beginning-of-buffer)
	      (while (search-forward-regexp "^Loading " nil t)
		(let ((start (point)))
		  (search-forward "...")
		  (backward-char 3)
		  (setq retval (cons (buffer-substring-no-properties start (point)) retval))))
	      retval)))
       (dolist (file (get-loads-from-*Messages*))
	  (princ (format "(load \"%s\")\n" file))))
    #+END_SRC
    Reduce clutter by making backups and autosaves in certain directories
    #+BEGIN_SRC emacs-lisp
      (let ((backup-dir "~/.emacs.d/backups")
      (auto-saves-dir "~/.emacs.d/autosaves"))
  (dolist (dir (list backup-dir auto-saves-dir))
    (when (not (file-directory-p dir))
      (make-directory dir t)))
  (setq backup-directory-alist `(("." . ,backup-dir))
	undo-tree-history-directory-alist `(("." . ,backup-dir))
        auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
        auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
        tramp-backup-directory-alist `((".*" . ,backup-dir))
        tramp-auto-save-directory auto-saves-dir))
    #+END_SRC
   More stuff for dumping emacs
   #+BEGIN_SRC emacs-lisp
   (defun dump-load-path ()
  (interactive)
  (with-temp-buffer
    (insert (prin1-to-string `(setq load-path ',load-path)))
    (fill-region (point-min) (point-max))
    (write-file "~/.emacs.d/load-path.el")))

(defun dump-emacs ()
  (interactive)
  (shell-command "emacs --batch -l ~/.edump -eval '(dump-load-path)' -eval '(dump-emacs-portable \"~/emacs.dump\")'"))
  #+END_SRC
  Undo tree
  #+BEGIN_SRC emacs-lisp
         (use-package undo-tree
           :demand t
        :config
        (global-undo-tree-mode)
        )
#+END_SRC
Elcord - unnecessecary package i use to flex my emacs.
#+BEGIN_SRC emacs-lisp
(use-package elcord
 :defer 20
 :hook (prog-mode . elcord-mode)
 :config
 ;; Additional configuration can go here if needed
 )

  #+END_SRC
* Latex stuff
load auctex
#+BEGIN_SRC emacs-lisp
    (use-package auctex
    :defer 20
  #+END_SRC
Disable display of compilation log and add makeglossaries to the tex command for easy managament of glossaries
#+BEGIN_SRC emacs-lisp
  :config
  (setq TeX-show-compilation nil)
  (eval-after-load "tex" '(add-to-list 'TeX-command-list
				       '("Makeglossaries" "makeglossaries %s" TeX-run-command nil
					 (latex-mode)
					 :help "Run makeglossaries script, which will choose xindy or makeindex") t))
  #+END_SRC
  Customize font-lock for auctex to improve readability
  #+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'latex-mode (list (list "\\(«\\(.+?\\|\n\\)\\)\\(+?\\)\\(»\\)" '(1 'font-latex-string-face t) '(2 'font-latex-string-face t) '(3 'font-latex-string-face t))))
  #+END_SRC
  set up reftex for better reference management and auto-parse, also use pdf
  #+BEGIN_SRC emacs-lisp
    :config
      (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
      (add-hook 'latex-mode-hook 'turn-on-reftex)
      (setq reftex-plug-into-AUCTeX t)
      (add-hook 'LaTeX-mode-hook (function (lambda() (bind-key "C-c C-r" 'reftex-query-replace-document))))
      (add-hook 'LaTeX-mode-hook (function (lambda() (bind-key "C-c C-g" 'reftex-grep-document))))
      (add-hook 'TeX-mode-hook (lambda () (reftex-isearch-minor-mode))))
  (setq-default TeX-master nil)
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-PDF-mode t)
  #+END_SRC
  Define a function to delete the current macro in auctex
  #+BEGIN_SRC emacs-lisp
(defun TeX-remove-macro ()
 (interactive)
 (when (TeX-current-macro)
    (let ((bounds (TeX-find-macro-boundaries))
          (brace (save-excursion
                    (goto-char (1- (TeX-find-macro-end)))
                    (TeX-find-opening-brace))))
      (delete-region (1- (cdr bounds)) (cdr bounds))
      (delete-region (car bounds) (1+ brace)))
    t))
(add-hook 'LaTeX-mode-hook (lambda () (bind-key "M-DEL" 'TeX-remove-macro)))
(setq TeX-view-program-selection '((output-pdf "Zathura")))
#+END_SRC
A bit of IRC configuration stuff
#+BEGIN_SRC emacs-lisp
(setq rcirc-track-ignore-server-buffer-flag t)
(rcirc-track-minor-mode 1)
(setq alert-default-style 'libnotify)
(setq rcirc-notify-message "message from %s")
#+END_SRC
Magit - i dont use it that much
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :defer t
    :after (treemacs ivy)
    )
#+END_SRC
* GNUS stuff
I really like gnus :D makes it use smtp and some hydra stuff i took from a guide.
see https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org
#+BEGIN_SRC emacs-lisp
  (setq nnmail-treat-duplicates t)
  (use-package gnus
    :defer t
    )
  
    (setq message-send-mail-function 'smtpmail-send-it)
#+END_SRC
This is for encrypted authinfo
#+BEGIN_SRC emacs-lisp
  ;; (use-package epa-file
  ;; (epa-file-enable)
#+END_SRC
  Org-mime
  #+BEGIN_SRC emacs-lisp
     (use-package org-mime
       :after (org gnus)
     :defer t
     :config
    (setq org-mime-library 'mml))
 #+END_SRC
Signature Stuff
#+BEGIN_SRC emacs-lisp
(defun my-insert-html-signature ()
 (let ((signature "<div style=\"display: block; white-space: nowrap; border: 1px solid #000; text-decoration: underline;\">
    Erel Bitzan, student and gentoo GNU/linux user :D
 </div>"))
    (goto-char (point-max))
    (insert signature)))
#+END_SRC
more org-mime stuff
#+BEGIN_SRC emacs-lisp
 (add-hook 'org-mime-html-hook 'my-insert-html-signature)
(add-hook 'message-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c M-o") 'org-mime-htmlize)))
(add-hook 'org-mime-html-hook
          (lambda ()
            (org-mime-change-element-style
             "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
                           "#E6E1DC" "#232323"))))

(add-hook 'org-mime-html-hook
          (lambda ()
            (org-mime-change-element-style
             "blockquote" "border-left: 2px solid gray; padding-left: 4px;")))
 #+END_SRC
 Dianyou for searching in gnus
 #+BEGIN_SRC emacs-lisp
   (use-package dianyou
     :after (org gnus)
     :defer t
     )
#+END_SRC
The epic hydra from the guide, VERY usefull :D
#+BEGIN_SRC emacs-lisp
(eval-after-load 'gnus-group
  '(progn
     (defhydra hydra-gnus-group (:color blue)
       "
[_A_] Remote groups (A A) [_g_] Refresh
[_L_] Local groups        [_\\^_] List servers
[_c_] Mark all read       [_m_] Compose new mail
[_G_] Search mails (G G) [_#_] Mark mail
"
       ("A" gnus-group-list-active)
       ("L" gnus-group-list-all-groups)
       ("c" gnus-topic-catchup-articles)
       ("G" dianyou-group-make-nnir-groupx)
       ("g" gnus-group-get-new-news)
       ("^" gnus-group-enter-server-mode)
       ("m" gnus-group-new-mail)
       ("#" gnus-topic-mark-topic)
       ("q" nil))
     (define-key gnus-group-mode-map "y" 'hydra-gnus-group/body)))
#+END_SRC
Another hydra i took from the guide for summary-mode
#+BEGIN_SRC emacs-lisp
(eval-after-load 'gnus-sum
  '(progn
     (defhydra hydra-gnus-summary (:color blue)
       "
[_s_] Show thread   [_F_] Forward (C-c C-f)
[_h_] Hide thread   [_e_] Resend (S D e)
[_n_] Refresh (/ N) [_r_] Reply
[_!_] Mail -> disk  [_R_] Reply with original
[_d_] Disk -> mail  [_w_] Reply all (S w)
[_c_] Read all      [_W_] Reply all with original (S W)
[_#_] Mark          [_G_] Search mails
"
       ("s" gnus-summary-show-thread)
       ("h" gnus-summary-hide-thread)
       ("n" gnus-summary-insert-new-articles)
       ("F" gnus-summary-mail-forward)
       ("!" gnus-summary-tick-article-forward)
       ("d" gnus-summary-put-mark-as-read-next)
       ("c" gnus-summary-catchup-and-exit)
       ("e" gnus-summary-resend-message-edit)
       ("R" gnus-summary-reply-with-original)
       ("r" gnus-summary-reply)
       ("W" gnus-summary-wide-reply-with-original)
       ("w" gnus-summary-wide-reply)
       ("#" gnus-topic-mark-topic)
       ("G" dianyou-group-make-nnir-group)
       ("q" nil))
     (define-key gnus-summary-mode-map "y" 'hydra-gnus-summary/body)))
#+END_SRC
Another hydra for article-mode
#+BEGIN_SRC emacs-lisp

(eval-after-load 'gnus-art
  '(progn
     (defhydra hydra-gnus-article (:color blue)
       "
[o] Save attachment        [F] Forward
[v] Play video/audio       [r] Reply
[d] CLI to download stream [R] Reply with original
[b] Open external browser  [w] Reply all (S w)
[f] Click link/button      [W] Reply all with original (S W)
[g] Focus link/button
"
       ("F" gnus-summary-mail-forward)
       ("r" gnus-article-reply)
       ("R" gnus-article-reply-with-original)
       ("w" gnus-article-wide-reply)
       ("W" gnus-article-wide-reply-with-original)
       ("q" nil))
     ;; y is not used by default
     (define-key gnus-article-mode-map "y" 'hydra-gnus-article/body)))
#+END_SRC
Another hydra for message-mode
#+BEGIN_SRC emacs-lisp

(eval-after-load 'message
  '(progn
     (defhydra hydra-message (:color blue)
  "
[_c_] Complete mail address
[_a_] Attach file
[_s_] Send mail (C-c C-c)
"
       ("c" counsel-bbdb-complete-mail)
       ("a" mml-attach-file)
       ("s" message-send-and-exit)
       ("i" dianyou-insert-email-address-from-received-mails)
       ("q" nil))))
(defun message-mode-hook-hydra-setup ()
  (local-set-key (kbd "C-c C-y") 'hydra-message/body))
(add-hook 'message-mode-hook 'message-mode-hook-hydra-setup)
#+END_SRC
* The end of the gnus stuff
Some tab bar stuff because i also love this
#+BEGIN_SRC emacs-lisp
(tab-bar-mode)
#+END_SRC
* Projectile because i absoloutely love this :D
#+BEGIN_SRC emacs-lisp

(use-package projectile
  :after (treemacs ivy counsel)
  :config
  (projectile-mode +1)
#+END_SRC
Reccomended keymap on linux
#+BEGIN_SRC emacs-lisp
 (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
 (setq projectile-indexing-method 'native)
 (setq projectile-completion-system 'ivy)
 (setq projectile-file-exists-remote-cache-expire (* 5 60))
 (setq projectile-require-project-root t))
 #+END_SRC
 The end of the projectile stuff.
 Custom function to select line and temporarily enable delete-selection
 #+BEGIN_SRC emacs-lisp
(defun select-line ()
 (interactive)
 (let ((delete-selection-mode t))
    (beginning-of-line)
    (set-mark-command nil)
    (end-of-line)
    (setq delete-selection-mode nil))) 
(global-set-key (kbd "C-c l") 'select-line)
#+END_SRC
* IVY
i dont use swiper because i hate how it looks
#+BEGIN_SRC emacs-lisp
    (use-package ivy
      :defer nil
     :config
     (ivy-mode 1)
     (setq ivy-use-virtual-buffers t)
     (setq enable-recursive-minibuffers t))

  (use-package counsel
   :after (ivy)
   :bind (("M-x" . counsel-M-x)
           ("<f1> f" . counsel-describe-function)
           ("<f1> v" . counsel-describe-variable)
           ("<f1> o" . counsel-describe-symbol)
           ("<f1> l" . counsel-find-library)
           ("<f2> i" . counsel-info-lookup-symbol)
           ("<f2> u" . counsel-unicode-char)
           ("C-c g" . counsel-git)
  	 ("C-x  C-f" . counsel-find-file)
           ("C-c j" . counsel-git-grep)
           ("C-c k" . counsel-ag)
           ("C-x l" . counsel-locate)
           ("C-S-o" . counsel-rhythmbox)
           :map minibuffer-local-map
           ("C-r" . counsel-minibuffer-history)))
#+END_SRC
Wind move is the most usefull package
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <left>")  'windmove-left)
(global-set-key (kbd "C-c <right>") 'windmove-right)
(global-set-key (kbd "C-c <up>")    'windmove-up)
(global-set-key (kbd "C-c <down>")  'windmove-down)
#+END_SRC
Use nerd icons for treemacs.
#+BEGIN_SRC emacs-lisp
  (use-package treemacs-nerd-icons
    :demand t
    :after (treemacs)
    :config
    (treemacs-load-theme "nerd-icons"))
#+END_SRC
Usefull keybind
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-k") 'kill-current-buffer)
#+END_SRC
system-packages, usefull package so i can watch my libraries compile(i use gentoo btw)
#+BEGIN_SRC emacs-lisp
(use-package system-packages
  :defer 20
  :config
 (setq system-packages-use-sudo t)
 (setq system-packages-package-manager 'emerge))
#+END_SRC
Indent-guide
#+BEGIN_SRC emacs-lisp
(add-hook 'markdown-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c C-o") 'markdown-export-to-html-and-open-in-nyxt)))
(use-package indent-guide
 :hook (python-mode . indent-guide-mode)
 :config
 (set-face-background 'indent-guide-face "gray")) ; Set the color of the indent guides
#+END_SRC

    Make auctex automatically parse the document and enable pdf mode
   #+BEGIN_SRC emacs-lisp
      (setq-default TeX-master nil)
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq-default TeX-PDF-mode t)
  #+END_SRC
  Disable automatic display of compilation log
  #+BEGIN_SRC emacs-lisp
   (setq TeX-show-compilation nil)
    #+END_SRC
Switch themes at certain times
#+BEGIN_SRC emacs-lisp
    (use-package doom-themes
      :defer 10
      )

  ;; Function to switch to gruvbox-dark-medium at 8 PM and default theme at 9 AM
  (defun switch-theme-based-on-time ()
    (interactive)
   (let ((current-hour (string-to-number (format-time-string "%H"))))
      (cond ((and (>= current-hour 20) (<= current-hour 23))
  	   (disable-theme t)
             (load-theme 'doom-sourcerer t))
            ((and (>= current-hour 9) (<= current-hour 19))
  	   (disable-theme t)
             (load-theme 'doom-nord-light t)))))

  ;; Schedule the theme switch function to run every hour
  (run-at-time "00:00" (* 60 60) 'switch-theme-based-on-time)
#+END_SRC
Guru mode because i have bad habits
#+BEGIN_SRC emacs-lisp
(use-package guru-mode
:defer nil
:config
(guru-global-mode +1))
#+END_SRC
auto-compile
#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
  )
  (use-package company-quickhelp
    :after (lsp-mode lsp-ui ivy counsel company)
    :hook (company-mode . company-quickhelp-mode))
  (use-package go-mode
    :after (lsp-mode lsp-ui ivy counsel company))
  (display-time-mode)
  (use-package lsp-haskell
    :after (lsp-mode lsp-ui haskell-mode ivy counsel company))
  (use-package haskell-mode
     :defer 20
    :after (lsp-mode lsp-ui ivy counsel company))
#+END_SRC
